#!/usr/bin/env node

var url = require('url');
var util = require('util');
var argv = require('optimist').argv;
var tilelive = require('..');

tilelive.protocols['mbtiles:'] = require('mbtiles');
tilelive.protocols['tilejson:'] = require('tilejson');

var commands = {
    'copy': '[from] [to] --bbox="[bbox]" --zoom=0-4 --concurrency=100'
};

function formatDuration(ms) {
    var seconds = ms / 1000;
    var parts = [];

    var days = (seconds / 86400) | 0;
    if (days) parts.push(days + ' ' + (days !== 1 ? 'days' : 'day'));
    seconds -= days * 86400;

    var hours = (hours / 3600) | 0;
    if (parts.length || days) parts.push(hours + ' ' + (hours !== 1 ? 'hours' : 'hour'));
    seconds -= hours * 3600;

    var minutes = (minutes / 60) | 0;
    if (parts.length || minutes) parts.push(minutes + ' ' + (minutes !== 1 ? 'minutes' : 'minute'));
    seconds -= minutes * 60;

    parts.push(seconds.toFixed(3) + ' ' + (seconds !== 1 ? 'seconds' : 'second'));
    return parts.join(' ');
}

switch (argv._[0]) {
    case 'copy':
        // if (!argv._[1]) usage();
        var from = url.parse(argv._[1] || '');
        if (!from.protocol) usage('Invalid from protocol: ' + argv._[1]);

        var to = url.parse(argv._[2] || '');
        if (!to.protocol) usage('Invalid to protocol: ' + argv._[2]);

        var bbox = String(argv.bbox || '-180,-90,180,90').split(/\s*[, ]\s*/).map(parseFloat);
        if (bbox.length !== 4) usage('Invalid bounding box: ' + util.inspect(argv.bbox));

        var zoom = String(argv.zoom || 0).split(/\s*[,-]\s*/).map(parseFloat);
        if (zoom.length === 1) zoom[1] = zoom[0];
        if (zoom.length != 2 || isNaN(zoom[0]) || isNaN(zoom[1])) usage('Invalid zoom range: ' + util.inspect(argv.zoom));

        var concurrency = parseInt(argv.concurrency || 100, 10);
        if (isNaN(concurrency)) usage('Invalid concurrency: ' + util.inspect(argv.concurrency));

        console.warn('Starting...');
        console.warn('         from: %s', url.format(from));
        console.warn('           to: %s', url.format(to));
        console.warn('         bbox: %s', util.inspect(bbox));
        console.warn('         zoom: %s', util.inspect(zoom));
        console.warn('  concurrency: %s', util.inspect(concurrency));
        console.warn('');

        tilelive.load(from, function(err, source) {
            if (err) throw err;
            tilelive.load(to, function(err, sink) {
                if (err) throw err;

                var copy = tilelive.copy(source, sink, bbox, zoom[0], zoom[1], concurrency);
                copy.notFound = 0;
                copy.on('progress', function() {

                });
                copy.on('warning', function(err) {
                    if (err.message === 'Tile does not exist') copy.notFound++;
                });
                copy.on('finished', function() {
                    console.warn('Finished.');
                    console.warn('       copied: %d', copy.copied);
                    console.warn('       failed: %d (%d not found)', copy.failed, copy.notFound);
                    console.warn('     duration: %s', formatDuration(Date.now() - copy.started));
                    process.exit();
                });
                copy.on('error', function(err) {
                    console.warn(err);
                });
            });
        });

        break;
    default:
        usage();
}

function usage(msg) {
    if (msg) console.warn(msg);
    if (commands[argv._[0]]) {
        console.warn('Usage: %s %s %s', argv.$0, argv._[0], commands[argv._[0]]);
    } else {
        console.warn('Usage: %s [command]', argv.$0);
        console.warn('Commands:');
        for (var cmd in commands) {
            console.warn('    %s %s', cmd, commands[cmd]);
        }
    }
    process.exit(1);
}